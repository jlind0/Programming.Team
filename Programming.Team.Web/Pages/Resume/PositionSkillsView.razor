@* Relationalish over ReactiveObjects for Position(experience) and Skill *@
@inherits ReactiveComponentBase<PositionSkillsViewModel>
@attribute [Authorize]

@if (ViewModel != null)
{
    @* TODO: do something for overly populated AlertViews in many scopes *@
    <AlertView Alert="ViewModel.Alert" />

    @* TODO: see both MudStack and MudChip in the same component *@
    <MudStack Wrap="Wrap.Wrap" Spacing="1" Row>
        @foreach (var e in ViewModel.Entities)
        {
            @* insta tag style keyword display *@
            <PositionSkillView ViewModel="e" />
        }
    </MudStack>

    @* TODO: all these anti-patterns in component naming *@

    @* "Add Skill" invokes *@
    <AddPositionSkillView ViewModel="ViewModel.AddViewModel" />
    @* here it has weird space-taking of popover cascading value
       so reverse-margin upward *@
    <MudElement Style="margin-top: -3rem;"></MudElement>
    <MudElement Class="d-flex justify-between">
        <MudButton
            OnClick="ViewModel.StartAdd.BindCommand<MouseEventArgs>()"
            Class="fw-bold"
            Variant="Variant.Filled"
            Color="Color.Primary">Add Skill</MudButton>
        @* "Suggest Skills" *@
        <SuggestAddSkillsForPositionView
            ViewModel="ViewModel.SuggestAddSkillsVM"
        />
        <MudButton
            OnClick="ViewModel.ExtractSkills.BindCommand<MouseEventArgs>()"
            Class="fw-bold"
            Variant="Variant.Filled"
            Color="Color.Primary">Extract Skills</MudButton>
        @if (ViewModel.RawSkills.Count > 0)
        {
            <MudStack Wrap="Wrap.Wrap" Row>
                @foreach (var e in ViewModel.RawSkills)
                {
                    <RawSkillView ViewModel="e" />
                }
            </MudStack>
        }
        <MudButton
            OnClick="ViewModel.AssociateSkills.BindCommand<MouseEventArgs>()"
            Class="fw-bold"
            Variant="Variant.Filled"
            Color="Color.Primary">Associate Skills</MudButton>
    </MudElement>
}

@code {
    protected override void OnInitialized()
    {
        if (ViewModel != null)
        {
            ViewModel.Entities.CollectionChanged += (s, e) =>
            {
                InvokeAsync(StateHasChanged);
            };
            ViewModel.RawSkills.CollectionChanged += (s, e) =>
            {
                InvokeAsync(StateHasChanged);
            };
        }
        base.OnInitialized();
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (ViewModel != null && firstRender)
        {
            await ViewModel.Load.Execute().GetAwaiter();

        }
        await base.OnAfterRenderAsync(firstRender);
    }
}
